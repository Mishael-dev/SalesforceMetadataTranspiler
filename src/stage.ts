// import { SalesforceMetadataTranspiler } from "./salesforceMetadataTranspiler";

// const transpilerConfig = {
//   apiVersion: "v65.0", // Required Salesforce API version
//   outputDirectory: "./output", // Optional, default './output'
//   validateOnly: true, // Optional, default false
// };

// const transpiler = new SalesforceMetadataTranspiler(transpilerConfig);

// const schema = {
//   type: "CustomObject",
//   metaData: [
//     {
//       label: "Asset",
//       pluralLabel: "Assets",
//       description:
//         "Represents a company asset used for tracking inventory and lifecycle status.",
//       deploymentStatus: "Deployed",
//       allowInChatterGroups: true,
//       nameField: {
//         label: "Asset Name",
//         type: "Text",
//         trackHistory: false,
//       },
//       enableActivities: true,
//       enableBulkApi: true,
//       enableFeeds: false,
//       enableHistory: true,
//       enableLicensing: false,
//       enableReports: true,
//       enableSearch: true,
//       enableSharing: true,
//       enableStreamingApi: true,
//       visibility: "Public",
//       fields: [
//         {
//           type: "AutoNumber",
//           label: "Asset ID",
//           fullName: "Asset_ID__c",
//           displayFormat: "ASSET-{YYYY}-{0000}",
//           description:
//             "Automatically generated identifier for each asset record, including year of creation.",
//           helpText:
//             "This field is auto-generated by Salesforce. Example: ASSET-2026-0001",
//           startingNumber: 1,
//         },
//         {
//           type: "Formula",
//           label: "Asset Status Label",
//           fullName: "Asset_Status_Label__c",
//           returnType: "Text",
//           formula:
//             'IF(NOT(ISBLANK(Asset_ID__c)), "ACTIVE: " & Name, "INACTIVE")',
//           blankOption: "BlankAsZero",
//           description:
//             "Displays a human-readable status based on whether the asset has been assigned an ID.",
//           helpText: "Shows ACTIVE or INACTIVE followed by the record name.",
//           externalId: false,
//           required: false,
//           unique: false,
//           trackHistory: false,
//         },
//       ],
//     },
//     {
//       label: "Device",
//       pluralLabel: "Devices",
//       description:
//         "Represents hardware devices assigned to employees or departments.",
//       deploymentStatus: "Deployed",
//       allowInChatterGroups: true,
//       nameField: {
//         label: "Device Name",
//         type: "Text",
//         trackHistory: false,
//       },
//       enableActivities: true,
//       enableBulkApi: true,
//       enableFeeds: false,
//       enableHistory: true,
//       enableLicensing: false,
//       enableReports: true,
//       enableSearch: true,
//       enableSharing: true,
//       enableStreamingApi: true,
//       visibility: "Public",
//       fields: [
//         {
//           type: "AutoNumber",
//           label: "Device Serial Number",
//           fullName: "Device_Serial__c",
//           displayFormat: "DEV-{000000}",
//           description: "System-generated serial number for internal tracking.",
//           helpText: "Internal serial number. Example: DEV-000123",
//           startingNumber: 1,
//         },
//         {
//           type: "Formula",
//           label: "Device Warranty Check",
//           fullName: "Warranty_Check__c",
//           returnType: "Text",
//           formula:
//             'IF(CONTAINS(Name, "Refurbished"), "Limited Warranty", "Full Warranty")',
//           blankOption: "BlankAsBlank",
//           description: "Determines warranty status based on the device name.",
//           helpText:
//             "Automatically flags warranty type based on whether the name contains 'Refurbished'.",
//           externalId: false,
//           required: false,
//           unique: false,
//           trackHistory: false,
//         },
//         {
//           type: "Checkbox",
//           label: "Active",
//           fullName: "Active__c",
//           defaultValue: true,
//           description: "Indicates if the record is active",
//           helpText: "Check this box if the record is currently active",
//           trackHistory: false,
//           required: false,
//           externalId: false,
//         },
//         {
//           type: "Currency",
//           fullName: "currency__c",
//           label: "currency",
//           defaultValue: 1234.56,
//           description: "This field stores the transaction currency",
//           inlineHelpText: "Enter the currency amount",
//           precision: 14,
//           scale: 4,
//           required: true,
//         },
//         {
//           fullName: "date__c",
//           label: "Date",
//           type: "Date",
//           defaultValue: "DATE(2026,1,19)",
//           description: "This is the main date field for records",
//           inlineHelpText: "Select the relevant date",
//           required: true,
//         },
//         {
//           fullName: "date_time__c",
//           label: "Date Time",
//           type: "DateTime",
//           defaultValue: "NOW()",
//           description: "This field stores the date and time of the event",
//           inlineHelpText: "Enter the date and time",
//           required: false,
//         },
//         {
//           fullName: "email__c",
//           label: "Email",
//           type: "Email",
//           description: "Primary email address of the contact",
//           inlineHelpText: "Enter a valid email address",
//           required: true,
//           caseSensitive: true,
//           unique: true,
//           externalId: false,
//         },
//         {
//           fullName: "geolocation__c",
//           label: "Geolocation",
//           type: "Location",
//           description: "Stores the geolocation coordinates",
//           inlineHelpText: "Enter latitude and longitude",
//           required: false,
//           displayLocationInDecimal: true,
//           scale: 6,
//         },
//         {
//           fullName: "Lookup_Field__c",
//           label: "Kitchen Sink Reference",
//           type: "Lookup",
//           referenceTo: "Kitchen_Sink__c",
//           relationshipName: "Kitchen_Sinks",
//           relationshipLabel: "Kitchen Sinks",
//           deleteConstraint: "SetNull",
//           description: "This is the description for the lookup field",
//           inlineHelpText: "This is the help text for the lookup field",
//           required: false,
//         },
//         {
//           fullName: "master_detail__c",
//           label: "Master Detail",
//           type: "MasterDetail",
//           referenceTo: "Account",
//           relationshipLabel: "Kitchen Sinks",
//           relationshipName: "Kitchen_Sinks",
//           relationshipOrder: 0,
//           reparentableMasterDetail: true,
//           writeRequiresMasterRead: false,
//           description: "master detail description",
//           inlineHelpText: "master-detail-help-text",
//         },
//         {
//           fullName: "number__c",
//           label: "Number Field",
//           type: "Number",
//           precision: 14,
//           scale: 2,
//           required: false,
//           unique: false,
//           isAIPredictionField: true,
//           description: "number description",
//           inlineHelpText: "number help",
//         },
//         {
//           fullName: "percent__c",
//           label: "Percent Field",
//           type: "Percent",
//           precision: 14,
//           scale: 2,
//           required: false,
//           description: "percent description",
//           inlineHelpText: "percent help",
//         },
//         {
//           fullName: "phone__c",
//           label: "Phone",
//           type: "Phone",
//           required: false,
//           description: "Phone number of the contact",
//           inlineHelpText: "+1 (555) 123-4567",
//         },
//         {
//           fullName: "picklist__c",
//           label: "Picklist Field",
//           type: "Picklist",
//           required: false,
//           description: "picklist description",
//           inlineHelpText: "picklist help text",
//           valueSet: {
//             restricted: true,
//             values: [
//               { fullName: "value 1", label: "value 1", default: false },
//               { fullName: "value 2", label: "value 2", default: false },
//               { fullName: "value 3", label: "value 3", default: false },
//             ],
//           },
//         },
//         {
//           fullName: "picklist_multi_select__c",
//           label: "Multiselect Picklist",
//           type: "MultiselectPicklist",
//           required: false,
//           description: "picklist description",
//           inlineHelpText: "picklist help text",
//           valueSet: {
//             restricted: true,
//             sorted: false,
//             values: [
//               { fullName: "value 1", label: "value 1", default: false },
//               { fullName: "value 2", label: "value 2", default: false },
//               { fullName: "value 3", label: "value 3", default: false },
//             ],
//           },
//           trackHistory: false,
//           visibleLines: 4,
//         },
//         {
//           fullName: "text__c",
//           label: "Text Field",
//           type: "Text",
//           length: 20,
//           required: false,
//           unique: false,
//           description: "text description",
//           inlineHelpText: "text help text",
//           externalId: false,
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "text_area__c",
//           label: "Text Area Field",
//           type: "TextArea",
//           required: false,
//           description: "text area description",
//           inlineHelpText: "text area help",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "text_area_encrypted__c",
//           label: "Encrypted Text Area",
//           type: "EncryptedText",
//           required: false,
//           length: 12,
//           maskChar: "asterisk",
//           maskType: "ssn",
//           description: "text area encrypted description",
//           inlineHelpText: "text area encrypted help",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "text_area_long__c",
//           label: "Long Text Area",
//           type: "LongTextArea",
//           length: 32768,
//           visibleLines: 3,
//           description: "text area long description",
//           inlineHelpText: "text area long help text",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "text_area_rich__c",
//           label: "Rich Text Area",
//           type: "Html",
//           length: 32768,
//           visibleLines: 25,
//           description: "text area rich description",
//           inlineHelpText: "text area rich help",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "time__c",
//           label: "Time Field",
//           type: "Time",
//           required: false,
//           description: "time description",
//           inlineHelpText: "time help text",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           fullName: "url__c",
//           label: "Website URL",
//           type: "Url",
//           required: false,
//           description: "url description",
//           inlineHelpText:
//             "Please enter a valid URL starting with http:// or https://",
//           trackHistory: false,
//           trackTrending: false,
//         },
//         {
//           type: "Summary",
//           label: "Rollup Summary",
//           fullName: "rollup_summary__c",
//           description: "roll up summary description",
//           inlineHelpText: "rollup summary text",
//           summarizedField: "kitchen_sink_child__c.CreatedDate",
//           summaryForeignKey: "kitchen_sink_child__c.Kitchen_Sink__c",
//           summaryOperation: "min",
//           trackHistory: false,
//           trackTrending: false,
//         },
//       ],
//     },
//   ],
// } as const;

// async function transpileSchema() {
//   const result = await transpiler.transpile(schema);

//   console.log(result);
// }

// transpileSchema();
/**
 * Architecture for Salesforce Metadata XML Generation
 */


// ============================================================================
// TYPES & INTERFACES
// ============================================================================

/**
 * XmlElement - Represents a single XML tag with optional children
 */
interface XmlElement {
  tag: string;
  value?: string | number | boolean;
  children?: XmlElement[];
}

/**
 * Field input type (from your JSON structure)
 */
interface Field {
  type: string;
  fullName: string;
  label: string;
  description?: string;
  inlineHelpText?: string;
  helpText?: string;
  required?: boolean;
  unique?: boolean;
  externalId?: boolean;
  trackHistory?: boolean;
  trackTrending?: boolean;
  [key: string]: any; // Allow additional properties
}

/**
 * Object metadata input type
 */
interface ObjectMetadata {
  label: string;
  pluralLabel: string;
  description?: string;
  deploymentStatus: string;
  allowInChatterGroups?: boolean;
  nameField: {
    label: string;
    type: string;
    trackHistory?: boolean;
  };
  enableActivities?: boolean;
  enableBulkApi?: boolean;
  enableFeeds?: boolean;
  enableHistory?: boolean;
  enableLicensing?: boolean;
  enableReports?: boolean;
  enableSearch?: boolean;
  enableSharing?: boolean;
  enableStreamingApi?: boolean;
  visibility?: string;
  fields?: Field[];
}

/**
 * Generator output format
 */
interface GeneratedMetadata {
  metadataType: 'CustomObject' | 'CustomField';
  apiName: string;
  parent?: string;
  xml: string;
}


// ============================================================================
// FIELD GENERATOR INTERFACE
// ============================================================================

/**
 * FieldXmlGenerator Interface
 * 
 * All field generators implement this interface
 * - supports(): Checks if this generator handles the field type
 * - generate(): Returns array of XmlElements for the field
 */
interface FieldXmlGenerator {
  supports(field: Field): boolean;
  generate(field: Field): XmlElement[];
}


// ============================================================================
// SPECIALIZED GENERATORS - Complex field types
// ============================================================================

/**
 * FormulaFieldXmlGenerator
 * 
 * Handles: Formula fields
 * Special handling: Uses returnType instead of type, maps blankOption to formulaTreatBlanksAs
 */
class FormulaFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Formula';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'formula', value: field.formula },
      { 
        tag: 'formulaTreatBlanksAs', 
        value: field.blankOption === 'BlankAsZero' ? 'BlankAsZero' : 'BlankAsBlank' 
      },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'type', value: field.returnType || 'Text' }, // Use returnType, not type
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * AutoNumberFieldXmlGenerator
 * 
 * Handles: AutoNumber fields
 * Special handling: Requires displayFormat, optional startingNumber
 */
class AutoNumberFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'AutoNumber';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'displayFormat', value: field.displayFormat },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'startingNumber', value: field.startingNumber },
      { tag: 'type', value: 'AutoNumber' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * LookupFieldXmlGenerator
 * 
 * Handles: Lookup fields
 * Special handling: Relationship fields (referenceTo, relationshipName, deleteConstraint)
 */
class LookupFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Lookup';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'deleteConstraint', value: field.deleteConstraint },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'referenceTo', value: field.referenceTo },
      { tag: 'relationshipLabel', value: field.relationshipLabel },
      { tag: 'relationshipName', value: field.relationshipName },
      { tag: 'required', value: field.required },
      { tag: 'type', value: 'Lookup' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * MasterDetailFieldXmlGenerator
 * 
 * Handles: MasterDetail fields
 * Special handling: Relationship order, reparentable options
 */
class MasterDetailFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'MasterDetail';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'referenceTo', value: field.referenceTo },
      { tag: 'relationshipLabel', value: field.relationshipLabel },
      { tag: 'relationshipName', value: field.relationshipName },
      { tag: 'relationshipOrder', value: field.relationshipOrder },
      { tag: 'reparentableMasterDetail', value: field.reparentableMasterDetail },
      { tag: 'writeRequiresMasterRead', value: field.writeRequiresMasterRead },
      { tag: 'type', value: 'MasterDetail' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * PicklistFieldXmlGenerator
 * 
 * Handles: Picklist fields
 * Special handling: Nested valueSet structure with values array
 */
class PicklistFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Picklist';
  }

  generate(field: Field): XmlElement[] {
    const elements: XmlElement[] = [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'required', value: field.required },
      { tag: 'type', value: 'Picklist' },
    ];

    // Build valueSet structure
    if (field.valueSet) {
      const valueSetChildren: XmlElement[] = [
        { tag: 'restricted', value: field.valueSet.restricted ?? true },
      ];

      // Build valueSetDefinition
      if (field.valueSet.values && field.valueSet.values.length > 0) {
        const definitionChildren: XmlElement[] = [
          { tag: 'sorted', value: field.valueSet.sorted ?? false },
        ];

        // Add each picklist value
        field.valueSet.values.forEach((val: any) => {
          definitionChildren.push({
            tag: 'value',
            children: [
              { tag: 'fullName', value: val.fullName },
              { tag: 'default', value: val.default ?? false },
              { tag: 'label', value: val.label },
            ].filter(el => el.value !== undefined) as XmlElement[],
          });
        });

        valueSetChildren.push({
          tag: 'valueSetDefinition',
          children: definitionChildren,
        });
      }

      elements.push({
        tag: 'valueSet',
        children: valueSetChildren,
      });
    }

    return elements.filter(el => el.value !== undefined || el.children) as XmlElement[];
  }
}


/**
 * MultiselectPicklistFieldXmlGenerator
 * 
 * Handles: MultiselectPicklist fields
 * Special handling: Same as Picklist + visibleLines
 */
class MultiselectPicklistFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'MultiselectPicklist';
  }

  generate(field: Field): XmlElement[] {
    const elements: XmlElement[] = [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'required', value: field.required },
      { tag: 'visibleLines', value: field.visibleLines },
      { tag: 'type', value: 'MultiselectPicklist' },
    ];

    // Build valueSet structure (same as Picklist)
    if (field.valueSet) {
      const valueSetChildren: XmlElement[] = [
        { tag: 'restricted', value: field.valueSet.restricted ?? true },
      ];

      if (field.valueSet.values && field.valueSet.values.length > 0) {
        const definitionChildren: XmlElement[] = [
          { tag: 'sorted', value: field.valueSet.sorted ?? false },
        ];

        field.valueSet.values.forEach((val: any) => {
          definitionChildren.push({
            tag: 'value',
            children: [
              { tag: 'fullName', value: val.fullName },
              { tag: 'default', value: val.default ?? false },
              { tag: 'label', value: val.label },
            ].filter(el => el.value !== undefined) as XmlElement[],
          });
        });

        valueSetChildren.push({
          tag: 'valueSetDefinition',
          children: definitionChildren,
        });
      }

      elements.push({
        tag: 'valueSet',
        children: valueSetChildren,
      });
    }

    return elements.filter(el => el.value !== undefined || el.children) as XmlElement[];
  }
}


/**
 * SummaryFieldXmlGenerator
 * 
 * Handles: Summary (Rollup) fields
 * Special handling: summarizedField, summaryForeignKey, summaryOperation
 */
class SummaryFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Summary';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'summarizedField', value: field.summarizedField },
      { tag: 'summaryForeignKey', value: field.summaryForeignKey },
      { tag: 'summaryOperation', value: field.summaryOperation },
      { tag: 'type', value: 'Summary' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * LocationFieldXmlGenerator
 * 
 * Handles: Location (Geolocation) fields
 * Special handling: displayLocationInDecimal, scale
 */
class LocationFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Location';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'displayLocationInDecimal', value: field.displayLocationInDecimal },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'required', value: field.required },
      { tag: 'scale', value: field.scale },
      { tag: 'type', value: 'Location' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * EncryptedTextFieldXmlGenerator
 * 
 * Handles: EncryptedText fields
 * Special handling: length, maskChar, maskType
 */
class EncryptedTextFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'EncryptedText';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'length', value: field.length },
      { tag: 'maskChar', value: field.maskChar },
      { tag: 'maskType', value: field.maskType },
      { tag: 'required', value: field.required },
      { tag: 'type', value: 'EncryptedText' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


/**
 * RichTextAreaFieldXmlGenerator
 * 
 * Handles: Html (RichTextArea) fields
 * Special handling: Maps "Html" type to "Html" in XML, includes length and visibleLines
 */
class RichTextAreaFieldXmlGenerator implements FieldXmlGenerator {
  supports(field: Field): boolean {
    return field.type === 'Html';
  }

  generate(field: Field): XmlElement[] {
    return [
      { tag: 'fullName', value: field.fullName },
      { tag: 'description', value: field.description },
      { tag: 'inlineHelpText', value: field.inlineHelpText || field.helpText },
      { tag: 'label', value: field.label },
      { tag: 'length', value: field.length },
      { tag: 'visibleLines', value: field.visibleLines },
      { tag: 'type', value: 'Html' },
    ].filter(el => el.value !== undefined) as XmlElement[];
  }
}


// ============================================================================
// GENERIC GENERATOR - Fallback for simple field types
// ============================================================================

/**
 * GenericFieldXmlGenerator
 * 
 * Handles: All simple field types (Text, TextArea, Number, Currency, etc.)
 * Strategy: Maps JSON keys 1:1 to XML tags with some key transformations
 * 
 * This is the FALLBACK generator - catches all field types not handled by specialized generators
 */
class GenericFieldXmlGenerator implements FieldXmlGenerator {
  supports(_field: Field): boolean {
    return true; // Catch-all - always returns true
  }

  generate(field: Field): XmlElement[] {
    // Filter out undefined/null values and the 'type' key (handled separately)
    const elements = Object.entries(field)
      .filter(([key, value]) => 
        value !== undefined && 
        value !== null && 
        key !== 'type' &&
        key !== 'helpText' && // Skip helpText, use inlineHelpText
        key !== 'blankOption' // Skip blankOption, field-specific generators handle it
      )
      .map(([key, value]) => ({
        tag: this.mapTagName(key),
        value,
      }));

    // Add type at the end
    elements.push({ tag: 'type', value: field.type });

    return elements;
  }

  /**
   * Map JSON keys to XML tag names
   * Some keys need transformation (e.g., helpText -> inlineHelpText)
   */
  private mapTagName(key: string): string {
    const mappings: Record<string, string> = {
      helpText: 'inlineHelpText',
      blankOption: 'formulaTreatBlanksAs',
    };
    return mappings[key] || key;
  }
}


// ============================================================================
// MAIN TRANSPILER - Registry & Orchestration
// ============================================================================

/**
 * FieldXmlTranspiler
 * 
 * Purpose: Orchestrates field XML generation
 * 
 * How it works:
 * 1. Maintains a registry of generators (specialized + generic fallback)
 * 2. For each field, finds the first generator that supports it
 * 3. Generates XmlElements using that generator
 * 4. Serializes elements to XML string
 * 
 * The generator order matters - specialized generators come first,
 * GenericFieldXmlGenerator comes last as fallback
 */
export class FieldXmlTranspiler {
  private generators: FieldXmlGenerator[] = [
    // Specialized generators (order matters - most specific first)
    new FormulaFieldXmlGenerator(),
    new AutoNumberFieldXmlGenerator(),
    new LookupFieldXmlGenerator(),
    new MasterDetailFieldXmlGenerator(),
    new PicklistFieldXmlGenerator(),
    new MultiselectPicklistFieldXmlGenerator(),
    new SummaryFieldXmlGenerator(),
    new LocationFieldXmlGenerator(),
    new EncryptedTextFieldXmlGenerator(),
    new RichTextAreaFieldXmlGenerator(),
    
    // Generic fallback (must be last)
    new GenericFieldXmlGenerator(),
  ];

  /**
   * Transpile a field to XML string
   */
  public transpile(field: Field): string {
    const elements = this.getElements(field);
    const body = this.serialize(elements);

    return [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<CustomField xmlns="http://soap.sforce.com/2006/04/metadata">',
      body,
      '</CustomField>',
    ].join('');
  }

  /**
   * Get XmlElements for a field using the appropriate generator
   */
  private getElements(field: Field): XmlElement[] {
    const generator = this.generators.find(g => g.supports(field));
    if (!generator) {
      throw new Error(`No generator found for field type: ${field.type}`);
    }
    return generator.generate(field);
  }

  /**
   * Serialize XmlElements to XML string
   */
  private serialize(elements: XmlElement[], indent = ''): string {
    return elements
      .map(el => {
        if (el.children) {
          // Element has nested children
          return `${indent}<${el.tag}>${this.serialize(el.children, indent)}</${el.tag}>`;
        }
        // Simple element with value
        const value = typeof el.value === 'string' ? this.escapeXML(el.value) : el.value;
        return `${indent}<${el.tag}>${value}</${el.tag}>`;
      })
      .join('');
  }

  /**
   * Escape special XML characters
   */
  private escapeXML(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}


// ============================================================================
// OBJECT METADATA TRANSPILER
// ============================================================================

/**
 * ObjectXmlTranspiler
 * 
 * Purpose: Generates XML for CustomObject metadata
 * 
 * How it works:
 * 1. Converts object metadata to XmlElements
 * 2. Handles nameField nested structure
 * 3. Serializes to XML string
 */
export class ObjectXmlTranspiler {
  /**
   * Transpile object metadata to XML string
   */
  public transpile(obj: ObjectMetadata): string {
    const elements = this.generateElements(obj);
    const body = this.serialize(elements);

    return [
      '<?xml version="1.0" encoding="UTF-8"?>',
      '<CustomObject xmlns="http://soap.sforce.com/2006/04/metadata">',
      body,
      '</CustomObject>',
    ].join('');
  }

  /**
   * Generate XmlElements for object metadata
   */
  private generateElements(obj: ObjectMetadata): XmlElement[] {
    const elements: XmlElement[] = [
      { tag: 'deploymentStatus', value: obj.deploymentStatus },
      { tag: 'description', value: obj.description },
      { tag: 'enableActivities', value: obj.enableActivities },
      { tag: 'enableBulkApi', value: obj.enableBulkApi },
      { tag: 'enableFeeds', value: obj.enableFeeds },
      { tag: 'enableHistory', value: obj.enableHistory },
      { tag: 'enableReports', value: obj.enableReports },
      { tag: 'enableSearch', value: obj.enableSearch },
      { tag: 'enableSharing', value: obj.enableSharing },
      { tag: 'enableStreamingApi', value: obj.enableStreamingApi },
      { tag: 'label', value: obj.label },
    ];

    // Add nameField (nested structure)
    if (obj.nameField) {
      elements.push({
        tag: 'nameField',
        children: [
          { tag: 'label', value: obj.nameField.label },
          { tag: 'type', value: obj.nameField.type },
        ],
      });
    }

    elements.push(
      { tag: 'pluralLabel', value: obj.pluralLabel },
      { tag: 'visibility', value: obj.visibility }
    );

    return elements.filter(el => el.value !== undefined || el.children) as XmlElement[];
  }

  /**
   * Serialize XmlElements to XML string
   */
  private serialize(elements: XmlElement[], indent = ''): string {
    return elements
      .map(el => {
        if (el.children) {
          return `${indent}<${el.tag}>${this.serialize(el.children, indent)}</${el.tag}>`;
        }
        const value = typeof el.value === 'string' ? this.escapeXML(el.value) : el.value;
        return `${indent}<${el.tag}>${value}</${el.tag}>`;
      })
      .join('');
  }

  /**
   * Escape special XML characters
   */
  private escapeXML(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}


// ============================================================================
// MAIN XML GENERATOR - Orchestrates everything
// ============================================================================

/**
 * XmlGenerator
 * 
 * Purpose: Main entry point for XML generation
 * 
 * How it works:
 * 1. Takes input with type and metaData
 * 2. Generates object API names from labels (e.g., "Asset" -> "Asset__c")
 * 3. Uses ObjectXmlTranspiler for objects
 * 4. Uses FieldXmlTranspiler for fields
 * 5. Returns array of GeneratedMetadata with apiName, parent, and xml
 */
export class XmlGenerator {
  private objectTranspiler = new ObjectXmlTranspiler();
  private fieldTranspiler = new FieldXmlTranspiler();

  /**
   * Generate XML for all objects and fields
   * @param input - Input data with type and metaData array
   * @returns Array of generated metadata with XML strings
   */
  public generate(input: { type: string; metaData: ObjectMetadata[] }): GeneratedMetadata[] {
    const results: GeneratedMetadata[] = [];

    input.metaData.forEach(obj => {
      // Generate object API name from label (e.g., "Asset" -> "Asset__c")
      const objectApiName = this.generateApiName(obj.label);

      // Generate object XML
      const objectXml = this.objectTranspiler.transpile(obj);
      results.push({
        metadataType: 'CustomObject',
        apiName: objectApiName,
        xml: objectXml,
      });

      // Generate field XMLs
      if (obj.fields && obj.fields.length > 0) {
        obj.fields.forEach(field => {
          const fieldXml = this.fieldTranspiler.transpile(field);
          results.push({
            metadataType: 'CustomField',
            parent: objectApiName,
            apiName: field.fullName,
            xml: fieldXml,
          });
        });
      }
    });

    return results;
  }

  /**
   * Generate Salesforce API name from label
   * Converts spaces to underscores and adds __c suffix
   */
  private generateApiName(label: string): string {
    return label.replace(/\s+/g, '_') + '__c';
  }
}


// ============================================================================
// USAGE EXAMPLE
// ============================================================================


// Import your JSON data
const input = {
  type: "CustomObject",
  metaData:[]
} 

// Create generator and generate XML
const generator = new XmlGenerator();
const results = generator.generate(input);

// Results is an array of:
// [
//   { metadataType: 'CustomObject', apiName: 'Asset__c', xml: '<?xml...' },
//   { metadataType: 'CustomField', parent: 'Asset__c', apiName: 'Asset_ID__c', xml: '<?xml...' },
//   ...
// ]

console.log(JSON.stringify(results, null, 2));
